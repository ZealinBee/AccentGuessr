datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Speaker {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  clips     Clip[]
  country String?

  accent Accent @relation(fields: [accentId], references: [id])
  accentId Int

  rounds Round[]
  matchRounds MatchRound[]
}

model Clip {
  id         Int      @id @default(autoincrement())
  audioUrl   String
  createdAt  DateTime @default(now())

  speakerId  Int
  speaker    Speaker  @relation(fields: [speakerId], references: [id])
  transcription Json?
}

model Accent {
  id          Int      @id @default(autoincrement())
  name        String
  region      Json
  description String?
  speakers Speaker[]
  type String?

  createdAt   DateTime @default(now())
}

model VolunteerSubmission {
  id          Int      @id @default(autoincrement())
  nativeLanguage  String
  countryOfOrigin String?
  ipAddress String

  submissionRecordings SubmissionRecording[]
  createdAt DateTime @default(now())
}

model SubmissionRecording {
  id          Int      @id @default(autoincrement())
  nativeLanguage String

  quoteId Int
  quote   Quote   @relation(fields: [quoteId], references: [id])

  volunteerSubmissionId Int
  volunteerSubmission VolunteerSubmission @relation(fields:[volunteerSubmissionId], references: id)
}

model Quote {
  id          Int      @id @default(autoincrement())
  joke String
  isUsed Boolean

  submissionRecordings SubmissionRecording[]
}

model User {
  id       String   @id @default(uuid())
  email    String   @unique
  picture  String?
  name     String?
  createdAt DateTime @default(now())

  games Game[]
  playerMatches MatchPlayer[]
}

model Game {
  id          Int      @id @default(autoincrement())
  totalScore Int

  rounds Round[]

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  createdAt DateTime? @default(now())
}

model Round {
  id          Int      @id @default(autoincrement())
  score Int
  guessLat Float
  guessLong Float

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId Int

  speaker Speaker @relation(fields: [speakerId], references: [id])
  speakerId Int
  createdAt DateTime? @default(now())
}

model Match {
  id          Int      @id @default(autoincrement())
  status MatchStatus @default(waiting)
  code Int
  createdAt    DateTime     @default(now())
  startedAt    DateTime?
  endedAt      DateTime?

  ownerId Int? @unique
  owner MatchPlayer?   @relation("OwnerMatch", fields: [ownerId], references: [id])

  currentRound Int @default(0)
  maxRounds Int @default(5)

  matchPlayers MatchPlayer[]
  matchRounds MatchRound[]
}

model MatchPlayer {
  id          Int       @id @default(autoincrement())

  matchId      Int
  match        Match     @relation(fields: [matchId], references: [id])

  userId       String?   // nullable â†’ guest possible
  user         User?     @relation(fields: [userId], references: [id])

  isGuest      Boolean   @default(false)
  name         String
  score        Int       @default(0)
  orderIndex   Int

  joinedAt     DateTime  @default(now())
  leftAt       DateTime?
  isConnected  Boolean   @default(true)

  guesses      PlayerGuess[]

  ownedMatch Match?       @relation("OwnerMatch")

}

model MatchRound {
  id           Int       @id @default(autoincrement())
  matchId      Int
  match        Match     @relation(fields: [matchId], references: [id])

  roundIndex   Int
  speakerId    Int
  speaker      Speaker   @relation(fields: [speakerId], references: [id])

  startedAt    DateTime  @default(now())
  endedAt      DateTime?
  isResolved   Boolean   @default(false)

  guesses      PlayerGuess[]
}

model PlayerGuess {
  id           Int       @id @default(autoincrement())
  roundId      Int
  round        MatchRound @relation(fields: [roundId], references: [id])
  playerId     Int
  player       MatchPlayer @relation(fields: [playerId], references: [id])

  guessLat     Float
  guessLong    Float
  score        Int?
  submittedAt  DateTime   @default(now())
}

enum MatchStatus {
  waiting
  in_progress
  finished
}